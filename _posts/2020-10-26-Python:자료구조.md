## 수 자료형

### 정수형 (Integer)

- 정수를 다루는 자료형
- 양의 정수, 음의 정수, 0

```python
a = 1000
print(a) #1000
a = -7
print(a) #-7
a = 0
print(a) # 0
```

### 실수형 (Real Number)

- 소수점 아래의 데이터를 포함하는 수 자료형
- 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리됨
- 소수부가 0이거나, 정수부가 0인 경우, 0을 생략하고 작성 가능

```python
a = 157.93
print(a) # 157.93

a = -1837.2
print(a) # -1837.2

a = 5.
print(a) # 5.0

a = -.7
print(a) # -0.7
```

#### e를 활용한 지수표현
- e, E를 이용한 지수 표현 방식을 이용 가능
	e 다음에 오는 수: 10의 지수부 (1e9 = 10의 9제곱)

$$
유효숫자 e ^{지수} = 유효숫자 * 10^{지수}
$$

- e를 활용한 지수표현이 덜 번거롭고, 자릿수 실수를 할 확률이 줄어듬

> **지수표현방식은 코딩 테스트에서 자주 활용됨**
_ex. 최단 경로문제_
도달할 수 없는 노드에 대한 최단 거리 = 무한(INF)
최단 경로로 가능한 최댓값이 10억 미만이라면, 무한(INF)를 표현할 때, 1e9로 표현

```python
# 10억의 지수 표현 방식
a = 1e9
print(a) # 1000000000.0

a = 75.25e1
print(a) # 752.5

a = 3954e-3
print(a) # 3.954
```

#### round를 이용한 실수 처리

> **컴퓨터의 수 데이터 처리 원리와 한계**
컴퓨터의 수 데이터 처리 → 2진수
실수 처리를 위해 부등 소수점(Floating-poing) 방식을 이용
IEEE754 표준은 실수형 저장을 위해 4바이트 혹은 8바이트의 고정 메모리를 할당하며, 
이로 인해 현대 컴퓨터 시스템은 대체로 실수 정보를 표현하는 정확도에 한계를 가짐

- 컴퓨터의 구조적 한계로, 일부 실수에서 미세한 오차가 발생하기도 함

```python
a = 0.3 + 0.6
print(a) #0.8999999999999

if a == 0.9:
	print(True)
else:
	print(False) # False
```

- 소수점 값 비교 작업이 필요한 문제의 경우, 실수 값의 정확한 비교를 위해 `round()` 함수를 이용
- `round((실수형데이터), (반올림하고자 하는 위치 -1))`
- 두 번째 `(반올림하고자 하는 위치 - 1)`을 생략하는 경우, 소수점 첫째 자리에서 반올림

```python
round(123.456, 2) # 123.46
```

> 코딩테스트에서 실수형 데이터 비교 시, 소수점 다섯 번째 자리에서 반올림한 결과가 같으면 정답으로 처리되므로
`round((실수형데이터), 4))`로 처리하도록 함

```python
a = 0.3 + 0.6
print(round(a, 4)) #0.9

if round(a, 4) ==0.9:
	print(True)
else:
	print(False) # True
```

### 수 자료형의 연산

- 프로그래밍에서는 사칙연산 (`+`, `-`, `x`, `/`)을 이용해 계산
- 이 중 나누기 연산자(`/`)를 사용시 주의

#### 나누기 연산자

- 나누기 연산자(`/`)의 결과는 기본적으로 실수형으로 처리
- 나머지 연산자(`%`): 나누기 연산의 나머지를 반환 (정수형)
- 몫 연산자(`//`): 나누기 연산의 몫을 반환 (정수형)

```python
a = 7
b = 3

print(a/b) #2.333333333333335

print(a%b) #1

print(a//b) #2

```

#### 거듭제곱 연산자
- 거듭제곱 연산자(**)

```python
a = 6
b = 3

print(a**b) #125
```

---

## 리스트 자료형

- 리스트: 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용

#### python의 리스트 특징

1.  C나 Java와 같은 프로그래밍 언어의 '배열(Array)'기능이 포함
2.  내부적으로 '연결 리스트 자료구조'를 채택
3.  `append()`, `remove()` 등의 메서드를 지원
4.  C++의 STL vector와 유사
5.  배열 혹은 테이블이라고 부르기도 함

### 리스트 만들기

- 리스트는 대괄호(`[]`) 안에 원소를 넣어 초기화하며,
- 쉼표(`,`)로 원소를 구분
- 리스트 내 원소에 접근할 때는 인덱스 값을 괄호안에 넣음
	이때, 인덱스는 0부터 시작
- 빈 리스트 선언: `list()`, `[]`

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a) #[1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[4]) # 5

a = list()
print(a) # []

a = []
print(a) # []
```

#### 크기가 N인 1차원 리스트 초기화

- 코딩 테스트 문제 중, 크기가 N인 1차원 리스트 초기화의 경우 다음과 같이 수행

```python
# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화
n = 10
a = [0] * n
print(a) # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### 리스트 인덱싱과 슬라이싱

- 인덱싱(Indexing): 인덱스 값을 입력하여, 리스트의 특정한 원소에 접근하는 것
- 양의 정수 & 음의 정수 사용이 가능
	음의 정수 사용시, 원소를 뒤에서부터 거꾸로 탐색
```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(a[-1]) # 9

print(a[-3]) # 7

a[3] = 7
print(a) # [1, 2, 3, 7, 5, 6, 7, 8, 9]
```

- 슬라이싱(Slicing): 리스트에서 연속적인 위치를 갖는 원소들을 가져오기 위해, 대괄호 안에 콜론`:`을 넣어 시작 인덱스와 (끝 인덱스 -1)을 설정
```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

print(a[1:4]) # [2, 3, 4]
```

### 리스트 컴프리핸션

- 리스트 컴프리핸션은 리스트를 초기화하는 방법 중 하나
- 대괄호`[]`안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i %2 == 1]
print(array) #[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
```

>일반적으로 작성된 코드와 리스트 컴프리핸션을 이용한 코드를 비교해보면,
리스트 컴프리핸션을 이용한 코드가 훨씬 짧고 간결한 것을 알 수 있음
```python
array = []
for i in range(20):
	if i % 2 == 1:
    	array.append(i)
print(array) #[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
```

```python

# 1부터 9까지의 수의 제곱값을 포함하는 리스트
array = [i**i for i in range(1, 10)]
print(array) # [1, 4, 9, 16, 25, 36, 49, 64, 81]
```
- 리스트 컴프리헨션은 코딩테스트에서 2차원 리스트를 초기화할 때 매우 효과적으로 활용
```python
# N x M 크기의 2차원 리스트 초기화
n = 3
m = 4
array = [[0] * m for _ in range(n)]
print(array) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
```

> **반복문에서의 언더바(`_`)의 역할**
파이썬 자료구조/알고리즘에서 반복을 수행하되 반복을 위한 변수 값을 무시할 때, 언더바(`_`)를 활용
```python
for _ in range(5):
	print("Hello World")
```

>**특정 크기의 2차원 리스트를 초기화할 때는 반드시 리스트 컴피리헨션을 이용**
```python
# 잘못된 N X M 크기의 2차원 리스트 초기화
n = 3
m = 4
array = [[0] * m] * n
print(array) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
array[1][1] = 5
print(array) # [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]]
```
`array[1][1]`의 값을 5로 바꾸었는데, 3개의 리스트에서 인덱스 1에 해당하는 원소값이 모두 5로 변경
이는 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문 (뒤의 두 리스트 = 첫 리스트의 레퍼런스)
따라서, 특정 크기를 갖는 2차원 리스트를 초기화할 때는리스트 컴프리헨션을 활용

### 리스트 관련 기타 메서드

|메서드명|사용법|설명|시간복잡도|
|------|---|---|---|
|**`append()`**|변수명.append()|리스트에 원소를 하나 삽입|O(1)|
|`sort()`|변수명.sort()|오름차순 정렬 (기본정렬)|O(NlogN)|
| |변수명.sort(reverse=True)|내림차순 정렬|O(N)|
|`reverse()`|변수명.reverse()|리스트 내 원소 순서를 뒤집음|O(N)
|**`insert()`**|insert(삽입 위치 인덱스, 삽입 값)|특정 인덱스 위치에 원소를 삽입|O(N)
|`count()`|변수명.count(특정 값)|리스트 내 특정 값을 갖는 데이터 갯수|O(N)
|**`remove()`**|변수명.remove(특정 값)|리스트 내 특정 값 원소를 제거|O(N)
###### _`remove()`사용 시, 리스트 내 특정 값이 여러 개일 경우, 하나만 제거_

```python
a = [1, 4, 3]
print("기본 리스트: ", a) # 기본리스트: [1, 4, 3]

# append() 메서드
a.append(2)
print("삽입: ", a) # 삽입: [1, 4, 3, 2]

# 오름차순 정렬
a.sort()
print("오른차순 정렬: ", a) # 오름차순 정렬: [1, 2, 3, 4]

# 내림차순 정렬
a.sort(reverse = True)
print("내림차순 정렬: ", a) # 내림차순 정렬: [4, 3, 2, 1]

# 리스트 원소 뒤집기
a.reverse()
print("원소 뒤집기: ", a) # 원소 뒤집기: [1, 2, 3, 4]

# 특정 인덱스에 데이터 추가
a.insert(2, 3)
print("인덱스 2에 3 추가: ", a) # 인덱스 2에 3 추가: [1, 2, 3, 3, 4]

# 특정 값이 데이터 개수 세기
print("값이 3인 데이터 개수: ", a.count(3)) # 2

# 특정 갓 데이터 삭제
a.remove(1)
print("값이 1인 데이터 삭제: ", a) # [2, 3, 3, 4]
```

#### 리스트 메서드와 시간복잡도

- `insert()`의 시간복잡도는 $$O(N)$$ vs. `append()`의 시간복잡도는 $$O(1)$$
	`insert()`는 중간에 원소를 삽입한 뒤 리스트 원소 위치를 재조정하기 때문
- `remove()`의 시간복잡도는 $$O(N)$$

> **특정 값의 원소를 모두 제거**하기 위해서는 아래와 같은 코드를 활용
```python
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}
# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not in remove_set]
print(result) # [1, 2, 4]
```

## 문자열 자료형

### 문자열 초기화

- 문자열 변수 초기화를 위해서는 큰따옴표(`""`)나 작은따옴포(`''`)를 이용
- 문자열이 큰따옴표로 구성된 경우, 내부적으로 작은따옴표 포함 가능
	반대로 문자열이 작은따옴표로 구성된 경우, 내부적으로 큰따옴표 포함 가능
- 백슬래시(`\`)를 이용하는 경우, 큰따옴표나 작은따옴표를 원하는만큼 포함 가능

```python
data = 'Hello World'
print(data) # Hello World

data = "Don't you know \"Python\"?"
print(data # Don't you know "Python"?
```

### 문자열 연산

- 덧셈(`+`): 문자열이 더해져서 연결
```python
a = "Hello"
b = "World"

print(a + " " + b) # Hello World
```

- 곱셈(`*`): 문자에 양의 정수를 곱하는 경우, 문자열이 그 값만큼 여러 번 더해짐

```python
a =. String"
print(a * 3) # StingStringString
```

- 인덱싱 & 슬라이싱: 문자열 내부는 리스트와 같이 처리되므로 인덱싱과 슬라이싱을 이용

```python
a = "ABCDEF"
print(a[2:4]) # CD
```

## 튜플 자료형

- 튜플 자료형은 리스트와 유사하나 일부 차이가 있음
1. 튜플은 한 번 선언된 값을 변경할 수 없음
2. 소괄호`()`를 이용함 (리스트는 대괄호`[]`를 이용)

아래 코드를 실행할 경우 튜플 타입은 변경할 수 없기 때문에 오류가 발생하며,
대입 연산자를 활용한 값 변경이 불가능함


```python
a = (1, 2, 3, 4)
print(a)

a[2] = 7
```

> 튜플 자료형은 그래프 알고리즘을 구현시 자주 활용
- `다익스트라 최단 경로 알고리즘` 등 최단 경로를 찾는 알고리즘 내부에는
	**우선순위 큐**를 활용하는데, 해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않음
- 따라서 우선순위 큐에 들어가는 데이터를 튜플로 구성하여 소스코드를 작성

- 튜플을 이용하면, 자신이 알고리즘을 잘못 작성하여 변경하면 안되는 값이 변경되고 있지 않은지 체크 가능
- 튜플은 리스트에 비해 상대적으로 공간 효율적
- 일반적으로 각 원소의 성질이 서로 다를 때 주로 사용

## 사전 자료형

### 사전 자료형 소개

- 사전 자료형은 키(key)와 값(value) 쌍을 데이터로 갖는 자료형
- 키-값 쌍을 데이터로 가진다는 점에서, 우리가 원하는 변경 불가능한 데이터를 키로 사용
###### 변경 불가능한 자료형: 수, 문자열, 튜폴 자료형과 같이 한번 초기화되면 변경이 불가능한 자료형, 튜플 자료형이 키로 사용되기도 함 (Q 22)

키-값 쌍으로 구성된 데이터를 담는 예시

|키(Key)|값(Value)|
|------|---|
|사과|Apple|
|바나나|Banana|
|코코넛|Coconut|

- 파이썬의 사전 자료형은 내부적으로 '해시 테이블'을 이용하므로 데이터 검색 및 수정에 있어 $$O(1)$$의 시간에 처리 가능함

> **해시테이블**
키-값 쌍으로 구성된 데이터를 처리함에 있어서 리스트보다 훨씬 빠르게 동작

```python
data = dict()
data['사과'] ='Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data) # {‘사과’: ‘Apple’, ‘바나나: ‘Banana’, ‘코코넛’: ‘Coconut’}
```

> **코딩 테스트에서의 사전 자료형 활용**
학생 번호 1부터 10,000,000까지 구성된 상황에서 최대 10,000명의 학생을 선택하여 특정 학생 번호가 주어졌을 때, 해당 학생이 선택된지 파악하는 방법
- 리스트를 이용하는 경우
1부터 10,000,000까지 각 번호가 선택되었는지를 저장하는 리스트를 생성
- 사전자료형을 이용하는 경우
10,000개의 데이터만 사전 자료구조에 넣어서 활용하며, 메모리 공간 절약

- `(원소) in (사전) `을 이용하여, 사전 자료형에 특정한 원소가 있는지 확인
리스트, 튜플에 대해서도 활용 가능함

>**Iterable 자료형**
파이썬에서 리스트, 문자열, 튜플 등 ‘순차적’정보를 담는 자료형을 뜻함
`in` 문법은 iterable 자료형에서 모두 활용 가능함

```python
data = dict()
data[‘사과’] = ‘Apple’
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

if ‘사과’ in data:
	print(“‘사과’를 키로 가지는 데이터가 존재합니다.”)
```

### 사전 자료형 관련 함수

- `keys()`: 키 데이터만 뽑아 리스트로 활용
- `values()`: 값 데이터만 뽑아서 리스트로 활용

```python
data = dict()
data[‘사과’] = ‘Apple’
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

# 키 데이터만 담은 리스트
key_list = data.keys()

# 값 데이터만 담은 리스트
value_list = data.values()
print(key_list) # dict_keys([‘사과’, ‘바나나’, ‘코코넛’])
print(value_list) # dict_values([‘Apple’, ‘Banana’, ‘Coconut’])

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
	print(data[key]) # Apple Banana Coconut
```

## 집합 자료형

### 집합 자료형 소개

- 집합(Set)을 처리하기 위한 자료형
- 집합은 기본적으로 리스트 혹은 문자열을 활용해 만들어냄

#### 집합의 특징
- 중복을 허용하지 않음
- 순서가 없음

#### 리스트 & 튜플 vs 사전 자료형 & 집합

- 리스트 & 튜플: 순서가 존재, 인덱싱을 통해 자료형의 값에 접근 가능
특정 원소가 존재하는지 검사하는 연산의 시간복잡도: $$O(N)$$
- 사전 자료형 & 집합: 순서가 없으며, 인덱싱으로 값을 얻을 수 없음
특정 원소가 존재하는지 검사하는 연산의 시간복잡도: $$O(1)$$

#### 사전 자료형 & 집합

- 사전 자료형: 키가 존재하여 키로 자료형의 값에 접근
- 집합 자료형: 키가 없으며 값 데이터만을 담고 있음

> **코딩 테스트에서의 집합 자료형 활용**
- ‘특정 데이터가 등장한 적이 있는지 여부’를 확인할 때 매우 효과적
- 이전 학생 번호가 주어졌을 때 해당 학생이 선택되었는지 여부를 출력하는 문제에서 효과적으로 활용 가능

#### 집합 자료형의 초기화

- `set()` 혹은 `{}`을 활용하여 집합 자료형을 초기화

```python
# 집합 자료형 초기화 방법 1
data = set([1, 1, 2, 3, 4, 4, 5])
print(data) # {1, 1, 2, 3, 4, 4, 5}

# 집합 자료형 초기화 방법 2
data = {1, 1, 2, 3, 4, 4, 5}
print(data) # {1, 1, 2, 3, 4, 4, 5}
```

### 집합 자료형의 연산

- 집합 자료형의 연산으로는 `합집합(|)`, `교집합(&)`, `차집합(-)` 연산이 있음

```python
a = set([1, 2, 3, 4, 5])
b = set([3, 4, 5, 6, 7])

print(a | b) # 합집합 # {1, 2, 3, 4, 5, 6, 7}
print(a & b) # 교집합 # {3, 4, 5}
print(a - b) # 차집합 # {1, 2}
```

### 집합 자료형 관련 함수

- `add()`: 집합 데이터에 값을 추가 (시간복잡도: $$O(1)$$)
- `update()`: 집합에 여러 개의 값을 한번에 추가
- `remove()`: 집합에서 특정 값을 제거 (시간복잡도: $$O(1)$$)

```python
data = set([1, 2, 3])
print(data) # {1, 2, 3}

# 새로운 원소 추가 add()
data.add(4)
print(data) # {1, 2, 3, 4}

# 새로운 원소 여러개 추가 update()
data.updata([5, 6])
print(data) # {1, 2, 3, 4, 5, 6}

# 특정한 값을 갖는 원소 삭제
data.remove(3)
print(data)
```