{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 수 자료형\n\n### 정수형 (Integer)\n\n- 정수를 다루는 자료형\n- 양의 정수, 음의 정수, 0\n\n```python\na = 1000\nprint(a) #1000\na = -7\nprint(a) #-7\na = 0\nprint(a) # 0\n```\n\n### 실수형 (Real Number)\n\n- 소수점 아래의 데이터를 포함하는 수 자료형\n- 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리됨\n- 소수부가 0이거나, 정수부가 0인 경우, 0을 생략하고 작성 가능\n\n```python\na = 157.93\nprint(a) # 157.93\n\na = -1837.2\nprint(a) # -1837.2\n\na = 5.\nprint(a) # 5.0\n\na = -.7\nprint(a) # -0.7\n```\n\n#### e를 활용한 지수표현\n- e, E를 이용한 지수 표현 방식을 이용 가능\n\te 다음에 오는 수: 10의 지수부 (1e9 = 10의 9제곱)\n\n$$\n유효숫자 e ^{지수} = 유효숫자 * 10^{지수}\n$$\n\n- e를 활용한 지수표현이 덜 번거롭고, 자릿수 실수를 할 확률이 줄어듬\n\n> **지수표현방식은 코딩 테스트에서 자주 활용됨**\n_ex. 최단 경로문제_\n도달할 수 없는 노드에 대한 최단 거리 = 무한(INF)\n최단 경로로 가능한 최댓값이 10억 미만이라면, 무한(INF)를 표현할 때, 1e9로 표현\n\n```python\n# 10억의 지수 표현 방식\na = 1e9\nprint(a) # 1000000000.0\n\na = 75.25e1\nprint(a) # 752.5\n\na = 3954e-3\nprint(a) # 3.954\n```\n\n#### round를 이용한 실수 처리\n\n> **컴퓨터의 수 데이터 처리 원리와 한계**\n컴퓨터의 수 데이터 처리 → 2진수\n실수 처리를 위해 부등 소수점(Floating-poing) 방식을 이용\nIEEE754 표준은 실수형 저장을 위해 4바이트 혹은 8바이트의 고정 메모리를 할당하며, \n이로 인해 현대 컴퓨터 시스템은 대체로 실수 정보를 표현하는 정확도에 한계를 가짐\n\n- 컴퓨터의 구조적 한계로, 일부 실수에서 미세한 오차가 발생하기도 함\n\n```python\na = 0.3 + 0.6\nprint(a) #0.8999999999999\n\nif a == 0.9:\n\tprint(True)\nelse:\n\tprint(False) # False\n```\n\n- 소수점 값 비교 작업이 필요한 문제의 경우, 실수 값의 정확한 비교를 위해 `round()` 함수를 이용\n- `round((실수형데이터), (반올림하고자 하는 위치 -1))`\n- 두 번째 `(반올림하고자 하는 위치 - 1)`을 생략하는 경우, 소수점 첫째 자리에서 반올림\n\n```python\nround(123.456, 2) # 123.46\n```\n\n> 코딩테스트에서 실수형 데이터 비교 시, 소수점 다섯 번째 자리에서 반올림한 결과가 같으면 정답으로 처리되므로\n`round((실수형데이터), 4))`로 처리하도록 함\n\n```python\na = 0.3 + 0.6\nprint(round(a, 4)) #0.9\n\nif round(a, 4) ==0.9:\n\tprint(True)\nelse:\n\tprint(False) # True\n```\n\n### 수 자료형의 연산\n\n- 프로그래밍에서는 사칙연산 (`+`, `-`, `x`, `/`)을 이용해 계산\n- 이 중 나누기 연산자(`/`)를 사용시 주의\n\n#### 나누기 연산자\n\n- 나누기 연산자(`/`)의 결과는 기본적으로 실수형으로 처리\n- 나머지 연산자(`%`): 나누기 연산의 나머지를 반환 (정수형)\n- 몫 연산자(`//`): 나누기 연산의 몫을 반환 (정수형)\n\n```python\na = 7\nb = 3\n\nprint(a/b) #2.333333333333335\n\nprint(a%b) #1\n\nprint(a//b) #2\n\n```\n\n#### 거듭제곱 연산자\n- 거듭제곱 연산자(**)\n\n```python\na = 6\nb = 3\n\nprint(a**b) #125\n```\n\n---\n\n## 리스트 자료형\n\n- 리스트: 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용\n\n#### python의 리스트 특징\n\n1.  C나 Java와 같은 프로그래밍 언어의 '배열(Array)'기능이 포함\n2.  내부적으로 '연결 리스트 자료구조'를 채택\n3.  `append()`, `remove()` 등의 메서드를 지원\n4.  C++의 STL vector와 유사\n5.  배열 혹은 테이블이라고 부르기도 함\n\n### 리스트 만들기\n\n- 리스트는 대괄호(`[]`) 안에 원소를 넣어 초기화하며,\n- 쉼표(`,`)로 원소를 구분\n- 리스트 내 원소에 접근할 때는 인덱스 값을 괄호안에 넣음\n\t이때, 인덱스는 0부터 시작\n- 빈 리스트 선언: `list()`, `[]`\n\n```python\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(a) #[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(a[4]) # 5\n\na = list()\nprint(a) # []\n\na = []\nprint(a) # []\n```\n\n#### 크기가 N인 1차원 리스트 초기화\n\n- 코딩 테스트 문제 중, 크기가 N인 1차원 리스트 초기화의 경우 다음과 같이 수행\n\n```python\n# 크기가 N이고, 모든 값이 0인 1차원 리스트 초기화\nn = 10\na = [0] * n\nprint(a) # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\n### 리스트 인덱싱과 슬라이싱\n\n- 인덱싱(Indexing): 인덱스 값을 입력하여, 리스트의 특정한 원소에 접근하는 것\n- 양의 정수 & 음의 정수 사용이 가능\n\t음의 정수 사용시, 원소를 뒤에서부터 거꾸로 탐색\n```python\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(a[-1]) # 9\n\nprint(a[-3]) # 7\n\na[3] = 7\nprint(a) # [1, 2, 3, 7, 5, 6, 7, 8, 9]\n```\n\n- 슬라이싱(Slicing): 리스트에서 연속적인 위치를 갖는 원소들을 가져오기 위해, 대괄호 안에 콜론`:`을 넣어 시작 인덱스와 (끝 인덱스 -1)을 설정\n```python\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nprint(a[1:4]) # [2, 3, 4]\n```\n\n### 리스트 컴프리핸션\n\n- 리스트 컴프리핸션은 리스트를 초기화하는 방법 중 하나\n- 대괄호`[]`안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화\n\n```python\n# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트\narray = [i for i in range(20) if i %2 == 1]\nprint(array) #[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n```\n\n>일반적으로 작성된 코드와 리스트 컴프리핸션을 이용한 코드를 비교해보면,\n리스트 컴프리핸션을 이용한 코드가 훨씬 짧고 간결한 것을 알 수 있음\n```python\narray = []\nfor i in range(20):\n\tif i % 2 == 1:\n    \tarray.append(i)\nprint(array) #[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n```\n\n```python\n\n# 1부터 9까지의 수의 제곱값을 포함하는 리스트\narray = [i**i for i in range(1, 10)]\nprint(array) # [1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n- 리스트 컴프리헨션은 코딩테스트에서 2차원 리스트를 초기화할 때 매우 효과적으로 활용\n```python\n# N x M 크기의 2차원 리스트 초기화\nn = 3\nm = 4\narray = [[0] * m for _ in range(n)]\nprint(array) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n```\n\n> **반복문에서의 언더바(`_`)의 역할**\n파이썬 자료구조/알고리즘에서 반복을 수행하되 반복을 위한 변수 값을 무시할 때, 언더바(`_`)를 활용\n```python\nfor _ in range(5):\n\tprint(\"Hello World\")\n```\n\n>**특정 크기의 2차원 리스트를 초기화할 때는 반드시 리스트 컴피리헨션을 이용**\n```python\n# 잘못된 N X M 크기의 2차원 리스트 초기화\nn = 3\nm = 4\narray = [[0] * m] * n\nprint(array) # [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\narray[1][1] = 5\nprint(array) # [[0, 5, 0, 0], [0, 5, 0, 0], [0, 5, 0, 0]]\n```\n`array[1][1]`의 값을 5로 바꾸었는데, 3개의 리스트에서 인덱스 1에 해당하는 원소값이 모두 5로 변경\n이는 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한 3개의 레퍼런스로 인식되기 때문 (뒤의 두 리스트 = 첫 리스트의 레퍼런스)\n따라서, 특정 크기를 갖는 2차원 리스트를 초기화할 때는리스트 컴프리헨션을 활용\n\n### 리스트 관련 기타 메서드\n\n|메서드명|사용법|설명|시간복잡도|\n|------|---|---|---|\n|**`append()`**|변수명.append()|리스트에 원소를 하나 삽입|O(1)|\n|`sort()`|변수명.sort()|오름차순 정렬 (기본정렬)|O(NlogN)|\n| |변수명.sort(reverse=True)|내림차순 정렬|O(N)|\n|`reverse()`|변수명.reverse()|리스트 내 원소 순서를 뒤집음|O(N)\n|**`insert()`**|insert(삽입 위치 인덱스, 삽입 값)|특정 인덱스 위치에 원소를 삽입|O(N)\n|`count()`|변수명.count(특정 값)|리스트 내 특정 값을 갖는 데이터 갯수|O(N)\n|**`remove()`**|변수명.remove(특정 값)|리스트 내 특정 값 원소를 제거|O(N)\n###### _`remove()`사용 시, 리스트 내 특정 값이 여러 개일 경우, 하나만 제거_\n\n```python\na = [1, 4, 3]\nprint(\"기본 리스트: \", a) # 기본리스트: [1, 4, 3]\n\n# append() 메서드\na.append(2)\nprint(\"삽입: \", a) # 삽입: [1, 4, 3, 2]\n\n# 오름차순 정렬\na.sort()\nprint(\"오른차순 정렬: \", a) # 오름차순 정렬: [1, 2, 3, 4]\n\n# 내림차순 정렬\na.sort(reverse = True)\nprint(\"내림차순 정렬: \", a) # 내림차순 정렬: [4, 3, 2, 1]\n\n# 리스트 원소 뒤집기\na.reverse()\nprint(\"원소 뒤집기: \", a) # 원소 뒤집기: [1, 2, 3, 4]\n\n# 특정 인덱스에 데이터 추가\na.insert(2, 3)\nprint(\"인덱스 2에 3 추가: \", a) # 인덱스 2에 3 추가: [1, 2, 3, 3, 4]\n\n# 특정 값이 데이터 개수 세기\nprint(\"값이 3인 데이터 개수: \", a.count(3)) # 2\n\n# 특정 갓 데이터 삭제\na.remove(1)\nprint(\"값이 1인 데이터 삭제: \", a) # [2, 3, 3, 4]\n```\n\n#### 리스트 메서드와 시간복잡도\n\n- `insert()`의 시간복잡도는 $$O(N)$$ vs. `append()`의 시간복잡도는 $$O(1)$$\n\t`insert()`는 중간에 원소를 삽입한 뒤 리스트 원소 위치를 재조정하기 때문\n- `remove()`의 시간복잡도는 $$O(N)$$\n\n> **특정 값의 원소를 모두 제거**하기 위해서는 아래와 같은 코드를 활용\n```python\na = [1, 2, 3, 4, 5, 5, 5]\nremove_set = {3, 5}\n# remove_set에 포함되지 않은 값만을 저장\nresult = [i for i in a if i not in remove_set]\nprint(result) # [1, 2, 4]\n```\n\n## 문자열 자료형\n\n### 문자열 초기화\n\n- 문자열 변수 초기화를 위해서는 큰따옴표(`\"\"`)나 작은따옴포(`''`)를 이용\n- 문자열이 큰따옴표로 구성된 경우, 내부적으로 작은따옴표 포함 가능\n\t반대로 문자열이 작은따옴표로 구성된 경우, 내부적으로 큰따옴표 포함 가능\n- 백슬래시(`\\`)를 이용하는 경우, 큰따옴표나 작은따옴표를 원하는만큼 포함 가능\n\n```python\ndata = 'Hello World'\nprint(data) # Hello World\n\ndata = \"Don't you know \\\"Python\\\"?\"\nprint(data # Don't you know \"Python\"?\n```\n\n### 문자열 연산\n\n- 덧셈(`+`): 문자열이 더해져서 연결\n```python\na = \"Hello\"\nb = \"World\"\n\nprint(a + \" \" + b) # Hello World\n```\n\n- 곱셈(`*`): 문자에 양의 정수를 곱하는 경우, 문자열이 그 값만큼 여러 번 더해짐\n\n```python\na =. String\"\nprint(a * 3) # StingStringString\n```\n\n- 인덱싱 & 슬라이싱: 문자열 내부는 리스트와 같이 처리되므로 인덱싱과 슬라이싱을 이용\n\n```python\na = \"ABCDEF\"\nprint(a[2:4]) # CD\n```\n\n## 튜플 자료형\n\n- 튜플 자료형은 리스트와 유사하나 일부 차이가 있음\n1. 튜플은 한 번 선언된 값을 변경할 수 없음\n2. 소괄호`()`를 이용함 (리스트는 대괄호`[]`를 이용)\n\n아래 코드를 실행할 경우 튜플 타입은 변경할 수 없기 때문에 오류가 발생하며,\n대입 연산자를 활용한 값 변경이 불가능함\n\n\n```python\na = (1, 2, 3, 4)\nprint(a)\n\na[2] = 7\n```\n\n> 튜플 자료형은 그래프 알고리즘을 구현시 자주 활용\n- `다익스트라 최단 경로 알고리즘` 등 최단 경로를 찾는 알고리즘 내부에는\n\t**우선순위 큐**를 활용하는데, 해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않음\n- 따라서 우선순위 큐에 들어가는 데이터를 튜플로 구성하여 소스코드를 작성\n\n- 튜플을 이용하면, 자신이 알고리즘을 잘못 작성하여 변경하면 안되는 값이 변경되고 있지 않은지 체크 가능\n- 튜플은 리스트에 비해 상대적으로 공간 효율적\n- 일반적으로 각 원소의 성질이 서로 다를 때 주로 사용\n\n## 사전 자료형\n\n### 사전 자료형 소개\n\n- 사전 자료형은 키(key)와 값(value) 쌍을 데이터로 갖는 자료형\n- 키-값 쌍을 데이터로 가진다는 점에서, 우리가 원하는 변경 불가능한 데이터를 키로 사용\n###### 변경 불가능한 자료형: 수, 문자열, 튜폴 자료형과 같이 한번 초기화되면 변경이 불가능한 자료형, 튜플 자료형이 키로 사용되기도 함 (Q 22)\n\n키-값 쌍으로 구성된 데이터를 담는 예시\n\n|키(Key)|값(Value)|\n|------|---|\n|사과|Apple|\n|바나나|Banana|\n|코코넛|Coconut|\n\n- 파이썬의 사전 자료형은 내부적으로 '해시 테이블'을 이용하므로 데이터 검색 및 수정에 있어 $$O(1)$$의 시간에 처리 가능함\n\n> **해시테이블**\n키-값 쌍으로 구성된 데이터를 처리함에 있어서 리스트보다 훨씬 빠르게 동작\n\n```python\ndata = dict()\ndata['사과'] ='Apple'\ndata['바나나'] = 'Banana'\ndata['코코넛'] = 'Coconut'\n\nprint(data) # {‘사과’: ‘Apple’, ‘바나나: ‘Banana’, ‘코코넛’: ‘Coconut’}\n```\n\n> **코딩 테스트에서의 사전 자료형 활용**\n학생 번호 1부터 10,000,000까지 구성된 상황에서 최대 10,000명의 학생을 선택하여 특정 학생 번호가 주어졌을 때, 해당 학생이 선택된지 파악하는 방법\n- 리스트를 이용하는 경우\n1부터 10,000,000까지 각 번호가 선택되었는지를 저장하는 리스트를 생성\n- 사전자료형을 이용하는 경우\n10,000개의 데이터만 사전 자료구조에 넣어서 활용하며, 메모리 공간 절약\n\n- `(원소) in (사전) `을 이용하여, 사전 자료형에 특정한 원소가 있는지 확인\n리스트, 튜플에 대해서도 활용 가능함\n\n>**Iterable 자료형**\n파이썬에서 리스트, 문자열, 튜플 등 ‘순차적’정보를 담는 자료형을 뜻함\n`in` 문법은 iterable 자료형에서 모두 활용 가능함\n\n```python\ndata = dict()\ndata[‘사과’] = ‘Apple’\ndata['바나나'] = 'Banana'\ndata['코코넛'] = 'Coconut'\n\nif ‘사과’ in data:\n\tprint(“‘사과’를 키로 가지는 데이터가 존재합니다.”)\n```\n\n### 사전 자료형 관련 함수\n\n- `keys()`: 키 데이터만 뽑아 리스트로 활용\n- `values()`: 값 데이터만 뽑아서 리스트로 활용\n\n```python\ndata = dict()\ndata[‘사과’] = ‘Apple’\ndata['바나나'] = 'Banana'\ndata['코코넛'] = 'Coconut'\n\n# 키 데이터만 담은 리스트\nkey_list = data.keys()\n\n# 값 데이터만 담은 리스트\nvalue_list = data.values()\nprint(key_list) # dict_keys([‘사과’, ‘바나나’, ‘코코넛’])\nprint(value_list) # dict_values([‘Apple’, ‘Banana’, ‘Coconut’])\n\n# 각 키에 따른 값을 하나씩 출력\nfor key in key_list:\n\tprint(data[key]) # Apple Banana Coconut\n```\n\n## 집합 자료형\n\n### 집합 자료형 소개\n\n- 집합(Set)을 처리하기 위한 자료형\n- 집합은 기본적으로 리스트 혹은 문자열을 활용해 만들어냄\n\n#### 집합의 특징\n- 중복을 허용하지 않음\n- 순서가 없음\n\n#### 리스트 & 튜플 vs 사전 자료형 & 집합\n\n- 리스트 & 튜플: 순서가 존재, 인덱싱을 통해 자료형의 값에 접근 가능\n특정 원소가 존재하는지 검사하는 연산의 시간복잡도: $$O(N)$$\n- 사전 자료형 & 집합: 순서가 없으며, 인덱싱으로 값을 얻을 수 없음\n특정 원소가 존재하는지 검사하는 연산의 시간복잡도: $$O(1)$$\n\n#### 사전 자료형 & 집합\n\n- 사전 자료형: 키가 존재하여 키로 자료형의 값에 접근\n- 집합 자료형: 키가 없으며 값 데이터만을 담고 있음\n\n> **코딩 테스트에서의 집합 자료형 활용**\n- ‘특정 데이터가 등장한 적이 있는지 여부’를 확인할 때 매우 효과적\n- 이전 학생 번호가 주어졌을 때 해당 학생이 선택되었는지 여부를 출력하는 문제에서 효과적으로 활용 가능\n\n#### 집합 자료형의 초기화\n\n- `set()` 혹은 `{}`을 활용하여 집합 자료형을 초기화\n\n```python\n# 집합 자료형 초기화 방법 1\ndata = set([1, 1, 2, 3, 4, 4, 5])\nprint(data) # {1, 1, 2, 3, 4, 4, 5}\n\n# 집합 자료형 초기화 방법 2\ndata = {1, 1, 2, 3, 4, 4, 5}\nprint(data) # {1, 1, 2, 3, 4, 4, 5}\n```\n\n### 집합 자료형의 연산\n\n- 집합 자료형의 연산으로는 `합집합(|)`, `교집합(&)`, `차집합(-)` 연산이 있음\n\n```python\na = set([1, 2, 3, 4, 5])\nb = set([3, 4, 5, 6, 7])\n\nprint(a | b) # 합집합 # {1, 2, 3, 4, 5, 6, 7}\nprint(a & b) # 교집합 # {3, 4, 5}\nprint(a - b) # 차집합 # {1, 2}\n```\n\n### 집합 자료형 관련 함수\n\n- `add()`: 집합 데이터에 값을 추가 (시간복잡도: $$O(1)$$)\n- `update()`: 집합에 여러 개의 값을 한번에 추가\n- `remove()`: 집합에서 특정 값을 제거 (시간복잡도: $$O(1)$$)\n\n```python\ndata = set([1, 2, 3])\nprint(data) # {1, 2, 3}\n\n# 새로운 원소 추가 add()\ndata.add(4)\nprint(data) # {1, 2, 3, 4}\n\n# 새로운 원소 여러개 추가 update()\ndata.updata([5, 6])\nprint(data) # {1, 2, 3, 4, 5, 6}\n\n# 특정한 값을 갖는 원소 삭제\ndata.remove(3)\nprint(data)\n```","excerpt":"수 자료형 정수형 (Integer) 정수를 다루는 자료형 양의 정수, 음의 정수, 0 실수형 (Real Number) 소수점 아래의 데이터를 포함하는 수 자료형 변수에 소수점을 붙인 수를 대입하면 실수형 변수로 처리됨 소수부가 0이거나, 정수부가 0…","fields":{"slug":"/Python자료형/"},"frontmatter":{"date":"Oct 16, 2020","title":"Python 자료형","tags":["python","자료형"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}